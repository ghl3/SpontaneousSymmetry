---
author: George
date: 2015-07-18 13:00:19.754170
layout: post
slug: monads
title: Monads
id: 446
---

Monads

I know that everyone has already written an introduction to Monads point, and at this point it's either a right-of-passage for a technical blog for some and for others it may be borderline spam.  But this is my blog, and I'll allowed to write about whatever I want, so I'm going to do my version anyway.  I'm not claiming that this is version is better or more complete than any other; only that it's mine.

The goal of this post is to describe what a Monad is and why it's a useful thing to think about to a person who knows how to program but doesn't necessarily use a language like Haskall (where it's more deeply embedded into the language).  In the end, a Monad, or the concept of Monads, is just a programming pattern that may be produce better code in certain situations, and that is the core of it's usefulness.  In Haskall, a monad is a bit more than that, as it has specific language syntax that makes it particularly useful.  I've found that many people who write about what Monads are come from that perspective, where both Haskall's syntax and Haskall's emphasis on purity make them more important.  To those, talking about a Mondad is similar to talking about a dictionary in python (which is core to the language and has nice syntactic support built-in).  My goal is to avoid that perspective and motivate the concept of Monads as a useful programming pattern.

Okay, let's for now forget the word Monad.  It's not helpful here.  Imagine instead that you're writing a program and you've created a function f.  Imagine further that f is a function that takes an object of one type and returns an object of that same type.  In a staticly typed langauge like Java one can enforce this constraint using the compiler.  In a dynamic language like python, this isn't enforced by the language, but certainly one can write such a function.  To be concrete, let's imagine that f takes a floating point value and returns a floating point value (for example, it may square that value):

Python:

```python
def f(x):
	return x*x
```


Java:
```java
public static float f(float x) {
	return x*x;
}
```


Simple.  What can we do with f?  It's clear that, because f takes and returns objects of the same type, we can call f twice in a row, or "compose" f with itself:


```python
x = f(f(10.0))
```

```java
float x = f(f(10.0));
```

In fact, we can do this as many times as we like, since we're always taking floats and returning floats:

```python
x = f(f(f(f(f(f(10))))))
```

```java
float x = f(f(f(f(f(f(10))))));
```

One can do this until their index finger gets tired of pressing "f".  This is all simple.  If I had a bunch of functions that all took floats and returned floats, I could freely compose those with each other and not worry about anything breaking (meaning, it would compile in Java and I wouldn't have any errors in python).  Some people would introduce the concept of a Monoid (not a spelling mistake, it's a different thing than a Monad), but if you understand the above, then adding fancy names isn't necessary at this point (but feel free to read about it yourself).


Now, let's imagine a slightly more complicated case.  Imagine we have a function g that takes one type but returns another type (again, in python, type alignment isn't enforced by a compiler, but it's all there).  One can think about this generally, but to be concrete, let's first that g takes a float and returns a list of floating point numbers.  To be really simple, let's just imagine it wraps the input float in a list:

```python
def g(x):
	return [x]
```


```java
public static List<Float> g(float x) {
	return new ArrayList<Float>(x);
}
```

This is just as simple before.  However, because the input type and the output types don't line up, we can't simply compose g with itself.  The following won't work:


```python
x = g(g(10.0))
```

```java
float x = g(g(10.0))
```

The python case will actually run, but it will create a list of lists, and we're going to assume that's not what we want in this case.  The Java version won't compile.

Again, it's not entirely clear why this is interesting, but the goal is to start simple and see how certain patterns emerge.  If we did want to call g many times in a row, we could do the following:


```python
x = g(10.0)
y = g(x[0])
```

```java
float x = g(10.0);
float y = g(x.get(0));
```

To use g twice in a row, we have to add an extra step where we get the value out of the list before putting it back into g.  It's unclear why one inherently wants to call g multiple times, but one can imagine that one has many functions that take floating point values and return lists, and if one wanted to call those in a row, one would have to similarly take values out of lists and pass them to these various functions.


Let's extend our example by introduction the function h.  h takes a floating point value.  If that value is greater than or equal to 0, it does what g does and puts it into a list.  But, if the value is less than 0, it returns an empty list:

```python
def g(x):
	if x >= 0:
		return [x]
	else:
		return []
```

```java
public static List<Float> g(float x){
	if (x >= 0) {
		return new ArrayList<Float>(x);
	} else {
		return new ArrayList<Float>();
	}
}
```

Let's say our goal was to call h on an value and then call g.  We know that we can't simply do this:

```python
g(h(10.0))
```

From before, we know that we have to get the result out of the return value of h before putting it into g.  Following our example before, we can try writing:


```python
x = h(10.0)
y = g(x[0]) 
```

```java
float x = h(10.0);
float y = g(x.get(0));
```

This works too, but it's clearly broken when we try to use a negative value:



```python
x = h(-10.0)
y = g(x[0]) 
```

```java
float x = h(-10.0);
float y = g(x.get(0));
```

The function h will return an empty list, and we'll get an exception in both python and Java when we try to get the first element from that list.  So, if we want to call h and then g on a value, we need to add more logic to make it work every time without throwing an exception.  We can write the following:



```python
x = h(-10.0)
if len(x) > 0:
	y = g(x[0]) 
else:
	y = []
```

```java
float x = h(-10.0);
float y;
if (x.size() > 0) {
	y = g(x.get(0));
} else {
	y = new ArrayList<Float>();;
}
```

And that works (assuming that we want y to be an empty list when h returns an empty list).  But all we really wanted to do was write g(h(-10.0)).  Instead, we had to write a lot of boilerplate to make that work.  That's not the end of the world, but as programmers, we like to look for patterns that can help us avoid boilerplate whenever possible.

Before we try to decompose the above into a more abstract pattern, let's quickly look at another simple example so we don't over-optimize for our specific functions g and h that work with lists.

Let's instead imagine that we have a function that takes a String and returns a pair of strings:


```python
def p(s):
	return (s, len(s))
```

```java
public static class StringPair {
	public final String s;
	public final Integer length;
	public StringPair(String s, Integer length) {
		this.s = s;
		this.length = length;
	}
}

public static StringPair p(String s) {
	return new StringPair(s, s.size());
```

Because Java doesn't have native tuples, we created a simple class to hold two strings.  But, aside from that, both versions of p do the same thing.  Like before, we can't call p twice in a row:

```python
p(p("foo"))
```

The function p returns a string pair, so we can to unpack the pair for this to work:

```python
x = p("foo")
y = p(x[0])
```

```java
StringPair x = p("foo");
StringPair y = p(x.s);
```

And now, like with our examples with g and h, this works.  However, it seems that we lost information.  What if we want the length returned by p to keep track of the total size of all strings that have gone through the p function?  After one call to "foo" it should be 3, but if we call p twice in a row on "foo", it should return 6 (3+3).  How can we accomplish this?


```python
x = p("foo")
y = p(x[0])

my_string = y[0]
my_count = x[1] + y[1]
```

```java
StringPair x = p("foo");
StringPair y = p(x.s);

String myString = y.s;
Integer myCount = x.length + y.length;
```

This works, but again, we added a lot of boilerplate.  All we wanted to do was call *something* that sort of feels like p(p("foo")).  But but we had to create all these intermediate variables and we had to keep unpacking data to actually get that to work.  Similar to the example with g and h, we'd like to come up with a pattern that makes the above simpler and clearer.



So, what do these two examples have in common, and how can we try to clean them both up to better express their underlying intentions?  In both cases, we want to do something that is conceptually similar to composing functions, but with some extra work that happens as well.  We really want to be able to define a special type of composition for the types of functions we're interested in that have additional rules which define how we pass the data into the functions when composing them.

Keeping our two examples in mind, let's think of the different type of rules we'd have to define to try to abstract what we're doing when composing these functions.  To be able to talk about both of our examples at the same time, let's label the types that our functions take and return.  In both examples, our functions g, h, and p take an object of type A and return an object of type B.  So, for g and h, A = float and B = List.  For p, A = string and B = Tuple or StringPair.  With that in mind, the main thing we need to abstract is:

"Imagine we have an object of type B.  How do we pass that object to a function f that takes an object of type A and returns an object of type B?"

With our g, h example, we did this by taking the first (and only) element (of type float) from the list and passing took function that took a float.  In our second example, we took a StringPair, passed the string component to the function, got back a new string pair, and then added their length fields.

So, if we have such a rule, then we can freely compose functions that take A and return a B.  This rule defines a special type of composition.  One could, if they were so inclined, give a name to this composition rule.  There are a number of names for it, but a common one is "lift".  In a sense, we're taking a function that takes an A and "lifting" it into a function that takes a B.  (We will later learn that defining a "lift" operation is one of the requirements for satisfying the Monad pattern, but again, that isn't relevant right now).


/*
If there were to do so, it would be very close to the definition of a Monad.  A Monad is just a set of rules that one writes down which allows one to compose functions together (even if they can't be composed using normal function composition).  To be a full Monad, one must specify some additional rules, but we will not here spell out those details.
*/

Let's define our lift function for the previous examples.  Recall that lift takes (an object of class B) and (a function that takes an A and returns a B) and returns a B.  

For our g, h example:

```python
def lift(g, x):
	if len(x) > 0:
		return g(x[0])
	else:
		return []
```

```java
public interface Function<T, U> {
	U call(T t);
}

public static List<Float> lift(Function<Float, List<Float>> g, List<Float> x) {
	if (x.size() > 0) {
		return f.call(x.get(0));
	} else {
		return new ArrayList<Float>();
	}
}

```

For our p example:

```python
def lift(p, x):
	s = x[0]
	initial_count = x[1]
	y = p(s)
	return (y[0], y[1]+initial_count)
```

```java
public static StringPair lift(Function<String, StringPair> p, StringPair x) {
	StringPair y = p.call(x.s);
	return new StringPair(y.x, x.length + y.length);
}
```

We've successfully moved our boilerplate code into our new "lift" functions.  This is a good step in the right direction: encapsulating messy functionality and boilerplate is usually a good thing.  We can now compose our g, h, and p functions in the following way:


```python
lift(g, lift(h, lift(g, lift(h, List(10.0)))));
``` 


```java
lift(g, lift(h, lift(g, lift(h, new ArrayListList<Float>(10.0)))));
``` 

This looks a lot like the composition that we really want to write!  The only somewhat annoying part is the expression in the inner-most nested function call where we have to wrap our raw value, 10.0, in a List.  This is because, as we saw before, our lift function's second parameter is List<Float>, and not float.

For the purpose of abstraction, we can wrap that action into another function that we'll here call "unit".  ("unit" is not a good or clear name at all.  I'll here admit that I'm giving it that name only due to conventions.  I think "wrap" would be a better name for what we want it to do).  Essentially, our new "unit" function takes an object of type A and returns an object of type B.

```python
def unit(x):
	return [x]
```

```java
public static List<Float> unit(float x) {
	return new ArrayList<Float>(x);
}
```


With these definitions, our composition looks like:



```python
lift(g, lift(h, lift(g, lift(h, unit(10.0)))))
``` 


```java
lift(g, lift(h, lift(g, lift(h, unit(10.0)))));
``` 

(It's satisfying that, at this point, the python and the java are exactly the same, other than a semi-colon.  Actually, semi-colons are legal in python, so I could make them literally the same code.  That's a good sign that our abstractions are moving in the right direction).


We're nearly done.  The next step is to encapsulate our "lift" and "unit" functions into a class (since we may want to define many different "lift" and "unit" functions for different examples, such as g, h vs p).  Let's go ahead and do it:


```python
class M:
	def lift(...)
	def unit(...)
```

```java
public static class M {
	public static List<Float> lift(Function<Float, List<Float>> f, List<Float> x) {
		...
	}
	public static List<Float> unit(Float f) {
		...
	}
}
```

As one can guess by it's name, "M" is a Monad (I'm not going to here go over the technical definition of a Monad.  For the purposes of this discussion, a class with the "lift" and "unit" functions is a Monad).  


This next step isn't strictly necessary, but it allows me to implement some final syntactic sugar.  In addition to "lift" and "unit", I'm going to define a function called "do".  All "do" will do is call either "lift" or "unit", depending on if the value is an A or a B; a List or a Float


```python
def do(g, x):
	if isinstance(x, list):
		return g(x)
	else:
		return g(unit(x))
```

```java
	public static List<Float> do(Function<Float, List<Float>> f, List<Float> x) {
		return lift(f, x);
	}
	public static List<Float> do(Function<Float, List<Float>> f, Float x) {
		return lift(f, unit(x));
	}
```

Finally, I can now write the full composition with this do function:

```python
do(h, do(g, do(h, do(g, 10.0))))
```

```java
do(h, do(g, do(h, do(g, 10.0))));
```

One can probably do better syntactically to make the composition prettier, but this is as far as I'll go, as I think it makes the point clear.  My expressing our "special composition" into the "lift" and "unit" functions, we are able to compose our g and h functions freely together (leveraging our "do" function).


So, once again, why is this a useful thing to have done, or to think about?  If you ask me, I think the most useful part of this exercise is in flexing our abstraction powers: to learn how to take a few examples of messy, boilerplate code and to be able to merge it into simpler constructs that better express the intent of what we want.  But, more tangibly, we've managed to separate the "what" (composing multiple functions) with the "how".  We can write the "how" in one place and then freely compose any functions that have our desired signature.  This all seems like a lot of work in the case where g and h are so simple, but in more complicated cases, being able to write f, g, and M separately and later combine them allows us to write business logic more clearly, and that's really one of the primary goals of any abstraction.


